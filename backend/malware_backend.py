import os
import requests
import pyzipper
from pathlib import Path
import platform
import subprocess
from backend.ssl_inspection import check_ssl_inspection
from tabulate import tabulate

API_URL = "https://mb-api.abuse.ch/api/v1/"
DEBUG = True  # Global toggle for debug output

def get_output_dir():
    """Ensure and return the output directory on Desktop"""
    desktop = Path(os.path.join(os.environ["USERPROFILE"], "Desktop"))
    output_dir = desktop / "MalwareBazaar_Downloads"
    output_dir.mkdir(parents=True, exist_ok=True)
    return output_dir

def fetch_more_hashes(tag, file_type, batch_size=20):
    """Fetch hashes from MalwareBazaar with SSL inspection and return entries, cert info box, and inspection status line."""
    
    # Step 1: Validate user input (either a tag or a file type must be selected)
    selected_tag = tag or file_type
    if not selected_tag:
        return [], "[ERROR] Please select either a tag or file type."

    # Step 2: Perform SSL certificate inspection before making any API call
    ssl_info = check_ssl_inspection("mb-api.abuse.ch")
    verify_ssl = ssl_info.get("verified", False)

    data = {
        "query": "get_taginfo",
        "tag": selected_tag,
        "limit": str(batch_size)
    }

    try:
        # Step 3: Send the POST request to MalwareBazaar using the correct SSL verification mode
        res = requests.post(API_URL, data=data, verify=verify_ssl, timeout=30)
        res.raise_for_status()

    except Exception as e:
        msg = "[ERROR] Failed to fetch hashes.\n"
        if DEBUG:
            msg += f"[DEBUG] {str(e)}\n"
        return [], msg + "Unable to connect to MalwareBazaar."

    # Step 4: Parse and normalize the JSON response into structured hash entries
    json_data = res.json()
    if json_data.get("query_status") == "no_results":
        return [], f"SSL inspection: {ssl_info['ssl_inspection']}\n[ERROR] No results found.\n"

    entries = []
    for entry in json_data.get("data", []):
        entries.append({
            "sha256": entry['sha256_hash'],
            "tags": entry.get('tags', ['Unknown']),
            "file_type": entry.get('file_type', 'unknown'),
            "file_type_mime": entry.get('file_type_mime', 'application/octet-stream'),
            "file_name": entry.get('file_name', f"{entry['sha256_hash']}.bin"),
            "first_seen": entry.get('first_seen', 'N/A'),
            "size": entry.get('file_size', 0)
        })

    # Step 5: Return the formatted SSL box (for display) and the parsed entries
    return entries, None, {
        "full": format_ssl_box(ssl_info),
        "status_line": f"SSL inspection: {ssl_info.get('ssl_inspection', 'Unknown')}"
    }


def download_and_unzip_file(entry, output_dir):
    """Download and unzip one sample from MalwareBazaar"""
    try:
        try:
            res = requests.post(API_URL, data={"query": "get_file", "sha256_hash": entry["sha256"]},
                                verify=True, timeout=30)
            res.raise_for_status()
        except requests.exceptions.SSLError:
            if DEBUG:
                print("[DEBUG] SSL download failed. Retrying without verification.")
            res = requests.post(API_URL, data={"query": "get_file", "sha256_hash": entry["sha256"]},
                                verify=False, timeout=30)
            res.raise_for_status()

        zip_path = output_dir / f"{entry['sha256']}.zip"
        with open(zip_path, "wb") as f:
            f.write(res.content)

        with pyzipper.AESZipFile(zip_path) as zf:
            zf.pwd = b'infected'
            zf.extractall(output_dir)
            for uf in zf.namelist():
                src = output_dir / uf
                dst = output_dir / entry["file_name"]
                if src.exists():
                    if dst.exists():
                        dst.unlink()
                    src.rename(dst)

        os.remove(zip_path)
        return "success"
    except Exception as e:
        return f"failed ({str(e)})"

def run_malwarebazaar_action(tag=None, file_type=None, limit=3, only_info=False):
    output_dir = get_output_dir()

    result = fetch_more_hashes(tag, file_type, batch_size=20)

    if len(result) == 3:
        hashes, error, ssl_info = result
    else:
        hashes, error = result
        ssl_info = None

    if error:
        return error + "\nDone!\n"

    results = []
    if ssl_info:
        results.append(ssl_info["full"].rstrip())
        results.append("")

    if not hashes:
        return "[ERROR] No hashes available.\nDone!\n"

    success_count = 0

    for entry in hashes:
        results.append("-----------------------------------------------------------------------------------")
        results.append(f" ")
        results.append(f"  - File Name: {entry['file_name']}")
        results.append(f"  - File Type: {entry['file_type']}, {entry['file_type_mime']}")
        results.append(f"  - Size: {entry['size']} bytes")
        results.append(f"  - SHA256: {entry['sha256']}")
        results.append(f"  - First Seen: {entry['first_seen']}")
        results.append(f"  - Tags: {', '.join(entry['tags'])}")

        if only_info:
            results.append("")  # spacing
            continue

        status = download_and_unzip_file(entry, output_dir)
        if status == "success":
            results.append("  - Download: success")
            success_count += 1
        else:
            results.append(f"  - Download: {status}")
        results.append("")

        if success_count >= int(limit):
            break

    if not only_info:
        results.append(f"{success_count} file(s) downloaded successfully.")
    results.append("Done!")
    return "\n".join(results)

def open_download_folder():
    path = str(get_output_dir())
    if platform.system() == "Windows":
        os.startfile(path)
    elif platform.system() == "Darwin":
        subprocess.run(["open", path])
    else:
        subprocess.run(["xdg-open", path])

from tabulate import tabulate

def format_ssl_box(cert_dict):
    """Return a simplified certificate table using only external borders"""
    rows = [
        ["Verified", "Yes" if cert_dict.get('verified') else "No"],
        ["Common Name (CN)", cert_dict.get('issuer_cn', 'Unknown')],
        ["Organization (O)", cert_dict.get('issuer_o', 'Unknown')],
        ["Subject CN", cert_dict.get('subject_cn', 'Unknown')],
        ["Valid Until", cert_dict.get('not_after', 'N/A')],
        ["SSL inspection", cert_dict.get('ssl_inspection', 'Unknown')]
    ]
    return tabulate(rows, tablefmt="outline")


