import os
import json
import requests
import pyzipper
from datetime import datetime
from pathlib import Path
import platform
import subprocess

API_URL = "https://mb-api.abuse.ch/api/v1/"

def get_verify_setting():
    """Return SSL verification setting based on environment variable"""
    use_custom_ca = os.getenv('USE_CUSTOM_CA', 'False').lower() == 'true'
    if use_custom_ca:
        return os.path.join(os.path.dirname(__file__), "Fortinet_CA_SSL.cer")
    return True

def get_output_dir():
    """Ensure and return the output directory on Desktop"""
    desktop = Path(os.path.join(os.environ["USERPROFILE"], "Desktop"))
    output_dir = desktop / "MalwareBazaar_Downloads"
    output_dir.mkdir(parents=True, exist_ok=True)
    return output_dir

def fetch_more_hashes(tag, file_type, batch_size=20):
    """Fetch more hashes than needed to compensate for failed downloads"""
    selected_tag = tag or file_type
    if not selected_tag:
        return [], "[ERROR] Please select either a tag or file type."

    data = {
        "query": "get_taginfo",
        "tag": selected_tag,
        "limit": str(batch_size)
    }

    try:
        res = requests.post(API_URL, data=data, verify=get_verify_setting(), timeout=30)
        res.raise_for_status()
        json_data = res.json()

        if json_data.get("query_status") == "no_results":
            return [], "[ERROR] No results found."

        entries = []
        for entry in json_data.get("data", []):
            entries.append({
                "sha256": entry['sha256_hash'],
                "tags": entry.get('tags', ['Unknown']),
                "file_type": entry.get('file_type', 'unknown'),
                "file_type_mime": entry.get('file_type_mime', 'application/octet-stream'),
                "file_name": entry.get('file_name', f"{entry['sha256_hash']}.bin"),
                "first_seen": entry.get('first_seen', 'N/A'),
                "size": entry.get('file_size', 0)
            })

        return entries, None

    except requests.exceptions.SSLError as ssl_err:
        debug_msg = "[DEBUG] SSL verification failed.\n"
        debug_msg += f"[DEBUG] Cert used: {get_verify_setting()}\n"
        debug_msg += f"[DEBUG] Cert file exists: {os.path.exists(get_verify_setting()) if isinstance(get_verify_setting(), str) else 'N/A'}\n"
        debug_msg += f"[ERROR] {str(ssl_err)}"
        return [], debug_msg
    except Exception as e:
        return [], f"[ERROR] Failed to fetch hashes: {str(e)}"

def download_and_unzip_file(entry, output_dir):
    """Download and unzip one sample from MalwareBazaar"""
    try:
        res = requests.post(API_URL, data={"query": "get_file", "sha256_hash": entry["sha256"]},
                            verify=get_verify_setting(), timeout=30)
        res.raise_for_status()
        zip_path = output_dir / f"{entry['sha256']}.zip"
        with open(zip_path, "wb") as f:
            f.write(res.content)

        with pyzipper.AESZipFile(zip_path) as zf:
            zf.pwd = b'infected'
            zf.extractall(output_dir)
            for uf in zf.namelist():
                src = output_dir / uf
                dst = output_dir / entry["file_name"]
                if src.exists():
                    if dst.exists():
                        dst.unlink()  # Delete the existing file
                    src.rename(dst)

        os.remove(zip_path)
        return "success"
    except Exception as e:
        return f"failed ({str(e)})"

def run_malwarebazaar_action(tag=None, file_type=None, limit=3, only_info=False):
    output_dir = get_output_dir()
    hashes, error = fetch_more_hashes(tag, file_type, batch_size=20)

    if error:
        return error + "\nDone!\n"
    if not hashes:
        return "[ERROR] No hashes available.\nDone!\n"

    results = []
    success_count = 0

    for entry in hashes:
        # Display file details
        results.append(f"{entry['file_name']}")
        results.append(f"- File Type: {entry['file_type']}, {entry['file_type_mime']}")
        results.append(f"- Size: {entry['size']} bytes")
        results.append(f"- SHA256: {entry['sha256']}")
        results.append(f"- First Seen: {entry['first_seen']}")
        results.append(f"- Tags: {', '.join(entry['tags'])}")

        if only_info:
            results.append("")  # spacing
            continue

        # Attempt to download
        status = download_and_unzip_file(entry, output_dir)
        if status == "success":
            results.append("- Download: success")  # highlight in green
            success_count += 1
        else:
            results.append(f"- Download: {status}")  # highlight in red
        results.append("")

        if success_count >= int(limit):
            break

    if not only_info:
        results.append(f"{success_count} file(s) downloaded successfully.")
    results.append("Done!")
    return "\n".join(results)

def open_download_folder():
    path = str(get_output_dir())
    if platform.system() == "Windows":
        os.startfile(path)
    elif platform.system() == "Darwin":
        subprocess.run(["open", path])
    else:
        subprocess.run(["xdg-open", path])
